import math
import random
import pandas as pd
import numpy as np
import toad
import warnings
import datetime
import xgboost as xgb
import lightgbm as lgb
from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
pd.options.mode.chained_assignment = None
from lightgbm import LGBMClassifier
from sklearn.metrics import roc_auc_score
from hyperopt import hp, tpe, fmin, Trials, STATUS_OK
import warnings
warnings.simplefilter(action='ignore', category = FutureWarning)
import gc
gc.enable()
import time
import pickle
from functools import reduce
from sklearn.model_selection import StratifiedKFold
np.random.seed(823)
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import seaborn as sns
from collections import defaultdict
import logging
import os
import psutil

### 注意 虽然该类中有特征及Y预处理功能 但是建议将预处理完的数据直接导入

class BasicIndexCal:
    @staticmethod
    def preprocess_cal(label, pred, exclude_value = [-1, -99, -999, -9999]):
        label, pred = np.array(label), np.array(pred)
        label = np.where((label == -1) | (label == 3), np.nan, np.where(label == 2, 0, label))
        pred = np.where(np.isin(pred, exclude_value), np.nan, pred)
        valid_idx = np.where((~np.isnan(label)) & (~np.isnan(pred)))[0]
        return label[valid_idx], pred[valid_idx]
    
    @staticmethod
    def ks_cal(label, pred):
        label, pred = BasicIndexCal.preprocess_cal(label, pred)
        if np.corrcoef(label, pred)[0, 1] > 0:
            fpr, tpr, _ = roc_curve(label, pred)
        else:
            fpr, tpr, _ = roc_curve(label, 1 - pred)
        return np.max(tpr - fpr)
    
    @staticmethod
    def ks_cal_manual(label, pred):
        label, pred = BasicIndexCal.preprocess_cal(label, pred)
        if np.corrcoef(label, pred)[0, 1] > 0:
            data = pd.DataFrame({'label': label, 'pred': pred}).sort_values(['pred'], ascending = False).reset_index(drop = True)
        else:
            data = pd.DataFrame({'label': label, 'pred': 1 - pred}).sort_values(['pred'], ascending = False).reset_index(drop = True)
        data['cum_pos'] = (data['label'] == 1).cumsum()
        data['cum_neg'] = (data['label'] == 0).cumsum()
        data['tpr'] = data['cum_pos'] / (data['label'] == 1).sum()
        data['fpr'] = data['cum_neg'] / (data['label'] == 0).sum()
        return np.max(data['tpr'] - data['fpr'])
    
    ### AUC的计算涉及到数值积分 np里面的梯形积分 在此不给出手撕版本
    @staticmethod
    def auc_cal(label, pred):
        label, pred = BasicIndexCal.preprocess_cal(label, pred)
        return max(roc_auc_score(label, pred), roc_auc_score(label, 1 - pred))
    
    ### IV的计算 手撕版本可见feature_stats_by_bin 可以对于唯一值分箱 也可以等频分箱
    @staticmethod
    def iv_cal(label, pred, return_sub = False):
        label, pred = BasicIndexCal.preprocess_cal(label, pred)
        return toad.stats.IV(pred, label, return_sub = return_sub)
    
    ### 基于分位点计算头尾部lift
    @staticmethod
    def lift_cal(label, pred, quantile = 0.1):
        label, pred = BasicIndexCal.preprocess_cal(label, pred)
        top_q_percent_idx = np.argsort(pred)[-int(quantile * len(pred)):]
        bot_q_percent_idx = np.argsort(pred)[:int(quantile * len(pred))]
        top_q_percent_lift = np.mean(label[top_q_percent_idx]) / np.mean(label)
        bot_q_percent_lift = np.mean(label[bot_q_percent_idx]) / np.mean(label)
        return bot_q_percent_lift, top_q_percent_lift

### 未完待续
class LightGBMHyperoptModeling(BasicIndexCal):
    